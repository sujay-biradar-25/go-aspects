package main

import (
	"encoding/json"
	"fmt"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/callgraph/cha"
	"golang.org/x/tools/go/callgraph/vta"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/go/ssa/ssautil"
)

type CallGraphResult struct {
	PackageID   string              `json:"package_id"`
	PackageName string              `json:"package_name"`
	ImportPath  string              `json:"import_path"`
	CallGraph   map[string][]string `json:"call_graph"`
	TotalFuncs  int                 `json:"total_functions"`
	TotalEdges  int                 `json:"total_edges"`
	Algorithm   string              `json:"algorithm"`
}

func main() {
	if len(os.Args) != 3 {
		log.Fatalf("Usage: %s <packages_json_file> <output_file>", os.Args[0])
	}

	packagesFile := os.Args[1]
	outputFile := os.Args[2]

	// Read the packages JSON response generated by the aspect
	data, err := ioutil.ReadFile(packagesFile)
	if err != nil {
		log.Fatalf("Failed to read packages file: %v", err)
	}

	// Parse the packages response metadata
	var response struct {
		NotHandled bool
		Compiler   string
		Arch       string
		Roots      []string
		Packages   []struct {
			ID              string            `json:"ID"`
			Name            string            `json:"Name"`
			PkgPath         string            `json:"PkgPath"`
			GoFiles         []string          `json:"GoFiles"`
			CompiledGoFiles []string          `json:"CompiledGoFiles"`
			Imports         map[string]string `json:"Imports"`
			ExportFile      string            `json:"ExportFile"`
		} `json:"Packages"`
	}

	if err := json.Unmarshal(data, &response); err != nil {
		log.Fatalf("Failed to parse packages JSON: %v", err)
	}

	// Set up Go environment for sandbox
	setupGoEnvironment()

	// Convert JSON packages to go/packages format
	pkgs := make([]*packages.Package, len(response.Packages))
	for i, jsonPkg := range response.Packages {
		pkg := &packages.Package{
			ID:              jsonPkg.ID,
			Name:            jsonPkg.Name,
			PkgPath:         jsonPkg.PkgPath,
			GoFiles:         jsonPkg.GoFiles,
			CompiledGoFiles: jsonPkg.CompiledGoFiles,
			ExportFile:      jsonPkg.ExportFile,
			Imports:         make(map[string]*packages.Package),
		}

		// Only load syntax for source packages (not stdlib or external deps)
		isSourcePackage := (pkg.ID != "" && (pkg.ID[0] != '@' || strings.HasPrefix(pkg.ID, "@//"))) && len(pkg.GoFiles) > 0
		isStdlib := isStandardLibraryPackage(pkg.PkgPath)

		if isSourcePackage {
			// Load syntax for source packages
			if err := loadPackageSyntax(pkg); err != nil {
				fmt.Fprintf(os.Stderr, "Warning: Failed to load syntax for %s: %v\n", pkg.PkgPath, err)
			}
		} else if isStdlib {
			// Create minimal type info for stdlib packages
			pkg.Types = types.NewPackage(pkg.PkgPath, pkg.Name)
		}

		pkgs[i] = pkg
	}

	// Filter valid packages for SSA
	validPackages := filterValidPackages(pkgs)
	if len(validPackages) == 0 {
		// Generate empty result instead of failing
		emptyResult := CallGraphResult{
			CallGraph:  make(map[string][]string),
			Algorithm:  "VTA",
			TotalFuncs: 0,
			TotalEdges: 0,
		}
		writeResult(outputFile, emptyResult)
		return
	}

	// Build SSA representation
	prog, _ := ssautil.AllPackages(validPackages, 0)
	prog.Build()

	ssaPackages := prog.AllPackages()
	if len(ssaPackages) == 0 {
		// Generate empty result
		emptyResult := CallGraphResult{
			CallGraph:  make(map[string][]string),
			Algorithm:  "VTA",
			TotalFuncs: 0,
			TotalEdges: 0,
		}
		writeResult(outputFile, emptyResult)
		return
	}

	// Build CHA call graph first
	chaCG := cha.CallGraph(prog)
	chaCG.DeleteSyntheticNodes()

	// Build VTA call graph
	allFuncs := ssautil.AllFunctions(prog)
	vtaCG := vta.CallGraph(allFuncs, chaCG)
	vtaCG.DeleteSyntheticNodes()

	// Extract call relationships for the main package only
	callGraph := make(map[string][]string)
	totalEdges := 0
	mainPackageID := ""
	mainPackageName := ""
	mainImportPath := ""

	// Find the main source package
	for _, pkg := range validPackages {
		if pkg.ID != "" && (pkg.ID[0] != '@' || strings.HasPrefix(pkg.ID, "@//")) && len(pkg.GoFiles) > 0 {
			mainPackageID = pkg.ID
			mainPackageName = pkg.Name
			mainImportPath = pkg.PkgPath
			break
		}
	}

	for fn, node := range vtaCG.Nodes {
		if fn == nil || node == nil {
			continue
		}

		// Only include functions from our main package
		if fn.Pkg == nil || fn.Pkg.Pkg == nil {
			continue
		}

		// Skip if not from main package
		if mainImportPath != "" && fn.Pkg.Pkg.Path() != mainImportPath {
			continue
		}

		// Safely get function name
		funcName := fmt.Sprintf("%s.%s", fn.Pkg.Pkg.Path(), fn.Name())

		var callees []string
		for _, edge := range node.Out {
			if edge == nil || edge.Callee == nil || edge.Callee.Func == nil {
				continue
			}

			calleeName := ""
			if edge.Callee.Func.Pkg != nil && edge.Callee.Func.Pkg.Pkg != nil {
				calleeName = fmt.Sprintf("%s.%s", edge.Callee.Func.Pkg.Pkg.Path(), edge.Callee.Func.Name())
			} else {
				calleeName = edge.Callee.Func.Name()
			}
			callees = append(callees, calleeName)
			totalEdges++
		}

		if len(callees) > 0 {
			callGraph[funcName] = callees
		}
	}

	// Create result
	result := CallGraphResult{
		PackageID:   mainPackageID,
		PackageName: mainPackageName,
		ImportPath:  mainImportPath,
		CallGraph:   callGraph,
		TotalFuncs:  len(callGraph),
		TotalEdges:  totalEdges,
		Algorithm:   "VTA",
	}

	writeResult(outputFile, result)
}

func setupGoEnvironment() {
	// Set up Go environment for sandbox
	if os.Getenv("GOROOT") == "" {
		if goroot := findGoRoot(); goroot != "" {
			os.Setenv("GOROOT", goroot)
		}
	}

	// Create a temporary go.mod
	tempDir, _ := os.Getwd()
	goModPath := filepath.Join(tempDir, "go.mod")
	if _, err := os.Stat(goModPath); os.IsNotExist(err) {
		goModContent := "module temp\n\ngo 1.21\n"
		ioutil.WriteFile(goModPath, []byte(goModContent), 0644)
	}
}

func loadPackageSyntax(pkg *packages.Package) error {
	if len(pkg.GoFiles) == 0 {
		return nil
	}

	tempDir, _ := os.Getwd()
	env := os.Environ()
	env = append(env, "GO111MODULE=on")
	env = append(env, "CGO_ENABLED=0")
	if goroot := os.Getenv("GOROOT"); goroot != "" {
		env = append(env, "GOROOT="+goroot)
		env = append(env, "PATH="+goroot+"/bin:"+os.Getenv("PATH"))
	}

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles |
			packages.NeedImports | packages.NeedDeps | packages.NeedExportFile |
			packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo |
			packages.NeedTypesSizes,
		Dir:        tempDir,
		Env:        env,
		BuildFlags: []string{"-mod=mod"},
		Tests:      false,
	}

	// Load syntax for the source file
	loadedPkgs, err := packages.Load(cfg, "file="+pkg.GoFiles[0])
	if err == nil && len(loadedPkgs) > 0 {
		loadedPkg := loadedPkgs[0]
		pkg.Syntax = loadedPkg.Syntax
		pkg.Fset = loadedPkg.Fset
		pkg.Types = loadedPkg.Types
		pkg.TypesInfo = loadedPkg.TypesInfo
	}

	return err
}

func filterValidPackages(pkgs []*packages.Package) []*packages.Package {
	var validPackages []*packages.Package
	for _, pkg := range pkgs {
		// Accept packages with syntax (source) OR types (stdlib)
		hasSyntax := pkg.Syntax != nil && len(pkg.Syntax) > 0
		hasTypes := pkg.Types != nil

		if hasSyntax || hasTypes {
			validPackages = append(validPackages, pkg)
		}
	}
	return validPackages
}

func isStandardLibraryPackage(pkgPath string) bool {
	stdlibPackages := map[string]bool{
		"fmt":      true,
		"context":  true,
		"os":       true,
		"time":     true,
		"net/http": true,
		"strings":  true,
		"strconv":  true,
		"io":       true,
		"errors":   true,
		"sync":     true,
		"runtime":  true,
		"syscall":  true,
		"bufio":    true,
		"net":      true,
		"net/url":  true,
		"sort":     true,
		"reflect":  true,
	}
	return stdlibPackages[pkgPath]
}

func findGoRoot() string {
	// Common Bazel Go SDK paths
	candidates := []string{
		"../external/go_sdk",
		"../../external/go_sdk",
		"../../../external/go_sdk",
		"../../../../external/go_sdk",
	}

	for _, candidate := range candidates {
		matches, _ := filepath.Glob(candidate)
		for _, match := range matches {
			if stat, err := os.Stat(filepath.Join(match, "bin", "go")); err == nil && !stat.IsDir() {
				return match
			}
		}
	}

	// Fallback to system GOROOT
	if goroot := os.Getenv("GOROOT"); goroot != "" {
		return goroot
	}

	return ""
}

func writeResult(outputFile string, result CallGraphResult) {
	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	// Write result as JSON
	resultData, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		log.Fatalf("Failed to marshal result: %v", err)
	}

	if err := ioutil.WriteFile(outputFile, resultData, 0644); err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}
}
